/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Main.ts":
/*!*********************!*\
  !*** ./src/Main.ts ***!
  \*********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndpointFactory = void 0;\nconst EndpointFactory_1 = __webpack_require__(/*! ./service/EndpointFactory */ \"./src/service/EndpointFactory.ts\");\nObject.defineProperty(exports, \"EndpointFactory\", ({ enumerable: true, get: function () { return EndpointFactory_1.EndpointFactory; } }));\nfunction setLib() {\n    endpointWasmModule().then((lib) => {\n        EndpointFactory_1.EndpointFactory.init(lib);\n        dispatchEvent(new CustomEvent('libInitialized'));\n    }).catch((err) => console.log(err));\n}\naddEventListener(\"wasmLoaded\", setLib);\n/**\n * TODO: komunikat o niepowodzeniu ladowania wasma - np ze prawdopodobnie brakuje plikÃ³w w public\n */ \n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/Main.ts?");

/***/ }),

/***/ "./src/api/Api.ts":
/*!************************!*\
  !*** ./src/api/Api.ts ***!
  \************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Api = void 0;\nconst IdGenerator_1 = __webpack_require__(/*! ./IdGenerator */ \"./src/api/IdGenerator.ts\");\nclass Api {\n    lib;\n    promises;\n    taskIdGenerator;\n    constructor(lib) {\n        this.lib = lib;\n        this.taskIdGenerator = new IdGenerator_1.IdGenerator();\n        this.promises = new Map();\n        this.setResultsCallback();\n    }\n    async runAsync(func) {\n        return new Promise((resolve, reject) => {\n            const taskId = this.generateId();\n            this.promises.set(taskId, { resolve, reject });\n            func(taskId);\n        });\n    }\n    resolveResult(result) {\n        if (result.status == true) {\n            this.promises.get(result.taskId).resolve(result.result);\n        }\n        else {\n            this.promises.get(result.taskId).reject(result.error);\n        }\n        this.promises.delete(result.taskId);\n    }\n    generateId() {\n        return this.taskIdGenerator.generateId();\n    }\n    setResultsCallback() {\n        this.lib.setResultsCallback((result) => this.resolveResult(result));\n    }\n}\nexports.Api = Api;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/Api.ts?");

/***/ }),

/***/ "./src/api/BaseNative.ts":
/*!*******************************!*\
  !*** ./src/api/BaseNative.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseNative = void 0;\nclass BaseNative {\n    _api;\n    constructor(api) {\n        this._api = api;\n    }\n    get api() {\n        if (!this._api) {\n            throw new Error(\"This API instance is no longer valid because the connection associated with it has been closed.\");\n        }\n        return this._api;\n    }\n    deleteApiRef() {\n        this._api = null;\n    }\n    async runAsync(func) {\n        if (!this.api) {\n            throw new Error(\"This API instance is no longer valid because the connection associated with it has been closed.\");\n        }\n        return this.api.runAsync(func);\n    }\n}\nexports.BaseNative = BaseNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/BaseNative.ts?");

/***/ }),

/***/ "./src/api/ConnectionNative.ts":
/*!*************************************!*\
  !*** ./src/api/ConnectionNative.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ConnectionNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass ConnectionNative extends BaseNative_1.BaseNative {\n    lastConnectionId = -1;\n    async newApi(_connectionPtr) {\n        throw new Error(\"Use the newConnection() - specialized version of method instead.\");\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.Connection_deleteConnection(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async newConnection() {\n        return this.runAsync((taskId) => this.api.lib.Connection_newConnection(taskId));\n    }\n    async deleteConnection(ptr) {\n        await this.runAsync((taskId) => this.api.lib.Connection_deleteConnection(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async connect(ptr, args) {\n        await this.runAsync((taskId) => this.api.lib.Connection_connect(taskId, ptr, args));\n        await this.getConnectionId(ptr, []);\n    }\n    async connectPublic(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.Connection_connectPublic(taskId, ptr, args));\n    }\n    async getConnectionId(ptr, args) {\n        if (this.lastConnectionId < 0) {\n            this.lastConnectionId = await this.runAsync((taskId) => this.api.lib.Connection_getConnectionId(taskId, ptr, args));\n        }\n        return this.lastConnectionId;\n    }\n    async listContexts(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.Connection_listContexts(taskId, ptr, args));\n    }\n    async disconnect(ptr, args) {\n        await this.runAsync((taskId) => this.api.lib.Connection_disconnect(taskId, ptr, args));\n    }\n}\nexports.ConnectionNative = ConnectionNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/ConnectionNative.ts?");

/***/ }),

/***/ "./src/api/CryptoApiNative.ts":
/*!************************************!*\
  !*** ./src/api/CryptoApiNative.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CryptoApiNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass CryptoApiNative extends BaseNative_1.BaseNative {\n    async newApi() {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_newCryptoApi(taskId));\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.CryptoApi_deleteCryptoApi(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async create(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_create(taskId, ptr, args));\n    }\n    async signData(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_signData(taskId, ptr, args));\n    }\n    async generatePrivateKey(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_generatePrivateKey(taskId, ptr, args));\n    }\n    async derivePrivateKey(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_derivePrivateKey(taskId, ptr, args));\n    }\n    async derivePublicKey(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_derivePublicKey(taskId, ptr, args));\n    }\n    async generateKeySymmetric(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_generateKeySymmetric(taskId, ptr, args));\n    }\n    async encryptDataSymmetric(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_encryptDataSymmetric(taskId, ptr, args));\n    }\n    async decryptDataSymmetric(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_decryptDataSymmetric(taskId, ptr, args));\n    }\n    async convertPEMKeytoWIFKey(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.CryptoApi_convertPEMKeytoWIFKey(taskId, ptr, args));\n    }\n}\nexports.CryptoApiNative = CryptoApiNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/CryptoApiNative.ts?");

/***/ }),

/***/ "./src/api/EventQueueNative.ts":
/*!*************************************!*\
  !*** ./src/api/EventQueueNative.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventQueueNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass EventQueueNative extends BaseNative_1.BaseNative {\n    async newApi(_connectionPtr) {\n        throw new Error(\"Use the newEventQueue() - specialized version of method instead.\");\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.EventQueue_deleteEventQueue(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async newEventQueue() {\n        return this.runAsync((taskId) => this.api.lib.EventQueue_newEventQueue(taskId));\n    }\n    async deleteEventQueue(ptr) {\n        await this.runAsync((taskId) => this.api.lib.EventQueue_deleteEventQueue(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async waitEvent(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.EventQueue_waitEvent(taskId, ptr, args));\n    }\n    async emitBreakEvent(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.EventQueue_emitBreakEvent(taskId, ptr, args));\n    }\n}\nexports.EventQueueNative = EventQueueNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/EventQueueNative.ts?");

/***/ }),

/***/ "./src/api/IdGenerator.ts":
/*!********************************!*\
  !*** ./src/api/IdGenerator.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IdGenerator = void 0;\nclass IdGenerator {\n    _id = 0;\n    generateId() {\n        this._id++;\n        return this._id;\n    }\n}\nexports.IdGenerator = IdGenerator;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/IdGenerator.ts?");

/***/ }),

/***/ "./src/api/InboxApiNative.ts":
/*!***********************************!*\
  !*** ./src/api/InboxApiNative.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InboxApiNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass InboxApiNative extends BaseNative_1.BaseNative {\n    async newApi(connectionPtr, threadApiPtr, storeApiPtr) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_newInboxApi(taskId, connectionPtr, threadApiPtr, storeApiPtr));\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.InboxApi_deleteInboxApi(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async create(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_create(taskId, ptr, args));\n    }\n    async createInbox(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_createInbox(taskId, ptr, args));\n    }\n    async updateInbox(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_updateInbox(taskId, ptr, args));\n    }\n    async getInbox(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_getInbox(taskId, ptr, args));\n    }\n    async listInboxes(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_listInboxes(taskId, ptr, args));\n    }\n    async getInboxPublicView(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_getInboxPublicView(taskId, ptr, args));\n    }\n    async deleteInbox(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_deleteInbox(taskId, ptr, args));\n    }\n    async prepareEntry(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_prepareEntry(taskId, ptr, args));\n    }\n    async sendEntry(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_sendEntry(taskId, ptr, args));\n    }\n    async readEntry(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_readEntry(taskId, ptr, args));\n    }\n    async deleteEntry(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_deleteEntry(taskId, ptr, args));\n    }\n    async listEntries(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_listEntries(taskId, ptr, args));\n    }\n    async createFileHandle(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_createFileHandle(taskId, ptr, args));\n    }\n    async writeToFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_writeToFile(taskId, ptr, args));\n    }\n    async openFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_openFile(taskId, ptr, args));\n    }\n    async readFromFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_readFromFile(taskId, ptr, args));\n    }\n    async seekInFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_seekInFile(taskId, ptr, args));\n    }\n    async closeFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_closeFile(taskId, ptr, args));\n    }\n    async subscribeForInboxEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_subscribeForInboxEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromInboxEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_unsubscribeFromInboxEvents(taskId, ptr, args));\n    }\n    async subscribeForEntryEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_subscribeForEntryEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromEntryEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.InboxApi_unsubscribeFromEntryEvents(taskId, ptr, args));\n    }\n}\nexports.InboxApiNative = InboxApiNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/InboxApiNative.ts?");

/***/ }),

/***/ "./src/api/StoreApiNative.ts":
/*!***********************************!*\
  !*** ./src/api/StoreApiNative.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StoreApiNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass StoreApiNative extends BaseNative_1.BaseNative {\n    async newApi(connectionPtr) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_newStoreApi(taskId, connectionPtr));\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.StoreApi_deleteStoreApi(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async create(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_create(taskId, ptr, args));\n    }\n    async createStore(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_createStore(taskId, ptr, args));\n    }\n    async updateStore(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_updateStore(taskId, ptr, args));\n    }\n    async deleteStore(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_deleteStore(taskId, ptr, args));\n    }\n    async getStore(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_getStore(taskId, ptr, args));\n    }\n    async listStores(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_listStores(taskId, ptr, args));\n    }\n    async createFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_createFile(taskId, ptr, args));\n    }\n    async updateFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_updateFile(taskId, ptr, args));\n    }\n    async updateFileMeta(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_updateFileMeta(taskId, ptr, args));\n    }\n    async writeToFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_writeToFile(taskId, ptr, args));\n    }\n    async deleteFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_deleteFile(taskId, ptr, args));\n    }\n    async getFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_getFile(taskId, ptr, args));\n    }\n    async listFiles(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_listFiles(taskId, ptr, args));\n    }\n    async openFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_openFile(taskId, ptr, args));\n    }\n    async readFromFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_readFromFile(taskId, ptr, args));\n    }\n    async seekInFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_seekInFile(taskId, ptr, args));\n    }\n    async closeFile(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_closeFile(taskId, ptr, args));\n    }\n    async subscribeForStoreEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_subscribeForStoreEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromStoreEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_unsubscribeFromStoreEvents(taskId, ptr, args));\n    }\n    async subscribeForFileEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_subscribeForFileEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromFileEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.StoreApi_unsubscribeFromFileEvents(taskId, ptr, args));\n    }\n}\nexports.StoreApiNative = StoreApiNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/StoreApiNative.ts?");

/***/ }),

/***/ "./src/api/ThreadApiNative.ts":
/*!************************************!*\
  !*** ./src/api/ThreadApiNative.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThreadApiNative = void 0;\nconst BaseNative_1 = __webpack_require__(/*! ./BaseNative */ \"./src/api/BaseNative.ts\");\nclass ThreadApiNative extends BaseNative_1.BaseNative {\n    async newApi(connectionPtr) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_newThreadApi(taskId, connectionPtr));\n    }\n    async deleteApi(ptr) {\n        await this.runAsync((taskId) => this.api.lib.ThreadApi_deleteThreadApi(taskId, ptr));\n        this.deleteApiRef();\n    }\n    async create(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_create(taskId, ptr, args));\n    }\n    async createThread(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_createThread(taskId, ptr, args));\n    }\n    async updateThread(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_updateThread(taskId, ptr, args));\n    }\n    async deleteThread(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_deleteThread(taskId, ptr, args));\n    }\n    async getThread(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_getThread(taskId, ptr, args));\n    }\n    async listThreads(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_listThreads(taskId, ptr, args));\n    }\n    async getMessage(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_getMessage(taskId, ptr, args));\n    }\n    async listMessages(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_listMessages(taskId, ptr, args));\n    }\n    async sendMessage(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_sendMessage(taskId, ptr, args));\n    }\n    async deleteMessage(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_deleteMessage(taskId, ptr, args));\n    }\n    async updateMessage(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_updateMessage(taskId, ptr, args));\n    }\n    async subscribeForThreadEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_subscribeForThreadEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromThreadEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_unsubscribeFromThreadEvents(taskId, ptr, args));\n    }\n    async subscribeForMessageEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_subscribeForMessageEvents(taskId, ptr, args));\n    }\n    async unsubscribeFromMessageEvents(ptr, args) {\n        return this.runAsync((taskId) => this.api.lib.ThreadApi_unsubscribeFromMessageEvents(taskId, ptr, args));\n    }\n}\nexports.ThreadApiNative = ThreadApiNative;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/api/ThreadApiNative.ts?");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndpointFactory = void 0;\nconst Main_1 = __webpack_require__(/*! ./Main */ \"./src/Main.ts\");\nObject.defineProperty(exports, \"EndpointFactory\", ({ enumerable: true, get: function () { return Main_1.EndpointFactory; } }));\nself.EndpointFactory = Main_1.EndpointFactory;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/index.ts?");

/***/ }),

/***/ "./src/service/BaseApi.ts":
/*!********************************!*\
  !*** ./src/service/BaseApi.ts ***!
  \********************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BaseApi = void 0;\nclass BaseApi {\n    _servicePtr;\n    constructor(ptr) {\n        this._servicePtr = ptr;\n    }\n    get servicePtr() {\n        if (this._servicePtr < 0) {\n            throw new Error(\"This API instance is no longer valid because the connection associated with it has been closed.\");\n        }\n        return this._servicePtr;\n    }\n    destroyRefs() {\n        this._servicePtr = -1;\n    }\n}\nexports.BaseApi = BaseApi;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/BaseApi.ts?");

/***/ }),

/***/ "./src/service/Connection.ts":
/*!***********************************!*\
  !*** ./src/service/Connection.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.Connection = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass Connection extends BaseApi_1.BaseApi {\n    native;\n    apisRefs = {};\n    nativeApisDeps = {};\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    /**\n     * Gets the ID of the current connection.\n     *\n     * @returns {number} ID of the connection.\n     */\n    async getConnectionId() {\n        return this.native.getConnectionId(this.servicePtr, []);\n    }\n    /**\n     * Gets list of contexts available for user.\n     *\n     * @param pagingQuery struct with list query parameters\n     * @returns {PagingList<Context>} struct containing a list of Contexts\n     */\n    async listContexts(pagingQuery) {\n        return this.native.listContexts(this.servicePtr, [pagingQuery]);\n    }\n    /**\n     * Disconnects from the Platform backed.\n     *\n     */\n    async disconnect() {\n        await this.native.disconnect(this.servicePtr, []);\n        console.log(\"on connection.disconnect\", { _servicePtr: this.servicePtr });\n        await this.freeApis();\n        await this.native.deleteConnection(this.servicePtr);\n    }\n    async freeApis() {\n        for (const apiId in this.apisRefs) {\n            if (this.nativeApisDeps[apiId]) {\n                await this.nativeApisDeps[apiId].deleteApi(this.apisRefs[apiId]._apiServicePtr);\n            }\n        }\n    }\n}\nexports.Connection = Connection;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/Connection.ts?");

/***/ }),

/***/ "./src/service/CryptoApi.ts":
/*!**********************************!*\
  !*** ./src/service/CryptoApi.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CryptoApi = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass CryptoApi extends BaseApi_1.BaseApi {\n    native;\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    /**\n     * Create a signature of given data and key.\n     *\n     * @param {Uint8Array} data the buffer to sign\n     * @param {string} privateKey the key used to sign data\n     * @returns {Uint8Array} signature.\n     */\n    async signData(data, privateKey) {\n        return this.native.signData(this.servicePtr, [data, privateKey]);\n    }\n    /**\n     * Generates a new private ECC key.\n     *\n     * @param {string} [randomSeed] optional string used as the base to generate the new key\n     * @returns {string} generated ECC key in WIF format.\n     */\n    async generatePrivateKey(randomSeed) {\n        return this.native.generatePrivateKey(this.servicePtr, [randomSeed]);\n    }\n    /**\n     * Generates a new private ECC key from a password using pbkdf2.\n     *\n     * @param {string} password the password used to generate the new key\n     * @param {string} salt random string (additional input for the hashing function)\n\n     * @returns {string} generated ECC key in WIF format.\n     */\n    async derivePrivateKey(password, salt) {\n        return this.native.derivePrivateKey(this.servicePtr, [password, salt]);\n    }\n    /**\n     * Generates a new public ECC key as a pair to an existing private key.\n     * @param {string} privateKey private ECC key in WIF format\n     * @returns {string} generated ECC key in BASE58DER format.\n     */\n    async derivePublicKey(privateKey) {\n        return this.native.derivePublicKey(this.servicePtr, [privateKey]);\n    }\n    /**\n     * Generates a new symmetric key.\n     * @returns {Uint8Array} generated key.\n     */\n    async generateKeySymmetric() {\n        return this.native.generateKeySymmetric(this.servicePtr, []);\n    }\n    /**\n     * Encrypts buffer with a given key using AES.\n     *\n     * @param {Uint8Array} data the buffer to encrypt\n     * @param {Uint8Array} symmetricKey the key used to encrypt data\n     * @returns {Uint8Array} encrypted data buffer.\n     */\n    async encryptDataSymmetric(data, symmetricKey) {\n        return this.native.encryptDataSymmetric(this.servicePtr, [data, symmetricKey]);\n    }\n    /**\n     * Decrypts buffer with a given key using AES.\n     *\n     * @param {Uint8Array} data the buffer to decrypt\n     * @param {Uint8Array} symmetricKey the key used to decrypt data\n     * @returns {Uint8Array} plain (decrypted) data buffer.\n     */\n    async decryptDataSymmetric(data, symmetricKey) {\n        return this.native.decryptDataSymmetric(this.servicePtr, [data, symmetricKey]);\n    }\n    /**\n     * Converts a given private key in PEM format to its WIF format.\n     *\n     * @param {string} pemKey the private key to convert\n     * @returns {string} private key in WIF format.\n     */\n    async convertPEMKeytoWIFKey(pemKey) {\n        return this.native.convertPEMKeytoWIFKey(this.servicePtr, [pemKey]);\n    }\n}\nexports.CryptoApi = CryptoApi;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/CryptoApi.ts?");

/***/ }),

/***/ "./src/service/EndpointFactory.ts":
/*!****************************************!*\
  !*** ./src/service/EndpointFactory.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EndpointFactory = void 0;\nconst Api_1 = __webpack_require__(/*! ../api/Api */ \"./src/api/Api.ts\");\nconst ConnectionNative_1 = __webpack_require__(/*! ../api/ConnectionNative */ \"./src/api/ConnectionNative.ts\");\nconst CryptoApiNative_1 = __webpack_require__(/*! ../api/CryptoApiNative */ \"./src/api/CryptoApiNative.ts\");\nconst EventQueueNative_1 = __webpack_require__(/*! ../api/EventQueueNative */ \"./src/api/EventQueueNative.ts\");\nconst InboxApiNative_1 = __webpack_require__(/*! ../api/InboxApiNative */ \"./src/api/InboxApiNative.ts\");\nconst StoreApiNative_1 = __webpack_require__(/*! ../api/StoreApiNative */ \"./src/api/StoreApiNative.ts\");\nconst ThreadApiNative_1 = __webpack_require__(/*! ../api/ThreadApiNative */ \"./src/api/ThreadApiNative.ts\");\nconst Connection_1 = __webpack_require__(/*! ./Connection */ \"./src/service/Connection.ts\");\nconst CryptoApi_1 = __webpack_require__(/*! ./CryptoApi */ \"./src/service/CryptoApi.ts\");\nconst EventQueue_1 = __webpack_require__(/*! ./EventQueue */ \"./src/service/EventQueue.ts\");\nconst InboxApi_1 = __webpack_require__(/*! ./InboxApi */ \"./src/service/InboxApi.ts\");\nconst StoreApi_1 = __webpack_require__(/*! ./StoreApi */ \"./src/service/StoreApi.ts\");\nconst ThreadApi_1 = __webpack_require__(/*! ./ThreadApi */ \"./src/service/ThreadApi.ts\");\n/**\n * Contains static factory methods - generators for Connection and APIs\n */\nclass EndpointFactory {\n    static api;\n    static eventQueueInstance;\n    /**\n     * //doc-gen:ignore\n     */\n    static init(lib) {\n        this.api = new Api_1.Api(lib);\n        // this.eventQueueNative = new EventQueueNative(api);\n        // this.connectionNative = new ConnectionNative(api);\n        // this.threadApiNative = new ThreadApiNative(api);\n        // this.storeApiNative = new StoreApiNative(api);\n        // this.inboxApiNative = new InboxApiNative(api);\n        // this.cryptoApiNative = new CryptoApiNative(api);\n    }\n    /**\n     * Gets the EventQueue instance.\n     *\n     * @returns {EventQueue} instance of EventQueue\n     */\n    static async getEventQueue() {\n        if (!this.eventQueueInstance) {\n            const nativeApi = new EventQueueNative_1.EventQueueNative(this.api);\n            const ptr = await nativeApi.newEventQueue();\n            this.eventQueueInstance = new EventQueue_1.EventQueue(nativeApi, ptr);\n        }\n        return this.eventQueueInstance;\n    }\n    /**\n     * Connects to the platform backend.\n     *\n     * @param {string} userPrivKey user's private key\n     * @param {string} solutionId ID of the Solution\n     * @param {string} platformUrl the Platform's Endpoint URL\n     * @returns {Connection} instance of Connection\n     */\n    static async platformConnect(userPrivKey, solutionId, platformUrl) {\n        const nativeApi = new ConnectionNative_1.ConnectionNative(this.api);\n        const ptr = await nativeApi.newConnection();\n        await nativeApi.connect(ptr, [userPrivKey, solutionId, platformUrl]);\n        return new Connection_1.Connection(nativeApi, ptr);\n    }\n    /**\n     * Connects to the Platform backend as a guest user.\n     *\n     * @param {string} solutionId ID of the Solution\n     * @param {string} platformUrl the Platform's Endpoint URL\n     *\n     * @returns {Connection} instance of Connection\n     */\n    static async platformConnectPublic(solutionId, platformUrl) {\n        const nativeApi = new ConnectionNative_1.ConnectionNative(this.api);\n        const ptr = await nativeApi.newConnection();\n        await nativeApi.connectPublic(ptr, [solutionId, platformUrl]);\n        return new Connection_1.Connection(nativeApi, ptr);\n    }\n    /**\n     * Creates an instance of the Thread API.\n     *\n     * @param {Connection} connection instance of Connection\n     *\n     * @returns {ThreadApi} instance of ThreadApi\n     */\n    static async createThreadApi(connection) {\n        if (\"threads\" in connection.apisRefs) {\n            throw new Error(\"ThreadApi already registered for given connection.\");\n        }\n        const nativeApi = new ThreadApiNative_1.ThreadApiNative(this.api);\n        const ptr = await nativeApi.newApi(connection.servicePtr);\n        await nativeApi.create(ptr, []);\n        connection.apisRefs[\"threads\"] = { _apiServicePtr: ptr };\n        connection.nativeApisDeps[\"threads\"] = nativeApi;\n        return new ThreadApi_1.ThreadApi(nativeApi, ptr);\n    }\n    /**\n     * Creates an instance of the Store API.\n     *\n     * @param {Connection} connection instance of Connection\n     *\n     * @returns {StoreApi} isntance of StoreApi\n     */\n    static async createStoreApi(connection) {\n        if (\"stores\" in connection.apisRefs) {\n            throw new Error(\"StoreApi already registered for given connection.\");\n        }\n        const nativeApi = new StoreApiNative_1.StoreApiNative(this.api);\n        const ptr = await nativeApi.newApi(connection.servicePtr);\n        connection.apisRefs[\"stores\"] = { _apiServicePtr: ptr };\n        connection.nativeApisDeps[\"stores\"] = nativeApi;\n        await nativeApi.create(ptr, []);\n        return new StoreApi_1.StoreApi(nativeApi, ptr);\n    }\n    /**\n     * Creates an instance of the Inbox API.\n     *\n     * @param {Connection} connection instance of Connection\n     * @param {ThreadApi} threadApi instance of ThreadApi\n     * @param {StoreApi} storeApi instance of StoreApi\n     * @returns {InboxApi} instance of InboxApi\n     */\n    static async createInboxApi(connection, threadApi, storeApi) {\n        if (\"inboxes\" in connection.apisRefs) {\n            throw new Error(\"InboxApi already registered for given connection.\");\n        }\n        const nativeApi = new InboxApiNative_1.InboxApiNative(this.api);\n        const ptr = await nativeApi.newApi(connection.servicePtr, threadApi.servicePtr, storeApi.servicePtr);\n        connection.apisRefs[\"inboxes\"] = { _apiServicePtr: ptr };\n        connection.nativeApisDeps[\"inboxes\"] = nativeApi;\n        await nativeApi.create(ptr, []);\n        return new InboxApi_1.InboxApi(nativeApi, ptr);\n    }\n    /**\n     * Creates an instance of the Crypto API.\n     *\n     * @returns {CryptoApi} instance of CryptoApi\n     */\n    static async createCryptoApi() {\n        const nativeApi = new CryptoApiNative_1.CryptoApiNative(this.api);\n        const ptr = await nativeApi.newApi();\n        await nativeApi.create(ptr, []);\n        return new CryptoApi_1.CryptoApi(nativeApi, ptr);\n    }\n}\nexports.EndpointFactory = EndpointFactory;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/EndpointFactory.ts?");

/***/ }),

/***/ "./src/service/EventQueue.ts":
/*!***********************************!*\
  !*** ./src/service/EventQueue.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EventQueue = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass EventQueue extends BaseApi_1.BaseApi {\n    native;\n    isPending = false;\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    async waitEvent() {\n        if (this.isPending) {\n            throw (\"WaitEvent() is already in a pending state waiting for new events\");\n        }\n        try {\n            return await this.native.waitEvent(this.servicePtr, []);\n        }\n        finally {\n            this.isPending = false;\n        }\n    }\n    async emitBreakEvent() {\n        return this.native.emitBreakEvent(this.servicePtr, []);\n    }\n}\nexports.EventQueue = EventQueue;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/EventQueue.ts?");

/***/ }),

/***/ "./src/service/InboxApi.ts":
/*!*********************************!*\
  !*** ./src/service/InboxApi.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InboxApi = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass InboxApi extends BaseApi_1.BaseApi {\n    native;\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    /**\n     * Creates a new Inbox.\n     *\n     * @param {string} contextId ID of the Context of the new Inbox\n     * @param {UserWithPubKey[]} users vector of UserWithPubKey structs which indicates who will have access to the created Inbox\n     * @param {UserWithPubKey[]} managers vector of UserWithPubKey structs which indicates who will have access (and management rights) to\n     * the created Inbox\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @param {FilesConfig} filesConfig struct to override default file configuration\n     * @returns {string} inbox ID\n     */\n    async createInbox(contextId, users, managers, publicMeta, privateMeta, filesConfig) {\n        return this.native.createInbox(this.servicePtr, [contextId, users, managers, publicMeta, privateMeta, filesConfig]);\n    }\n    /**\n     * Updates an existing Inbox.\n     *\n     * @param {string} inboxId ID of the Inbox to update\n     * @param {UserWithPubKey[]} users vector of UserWithPubKey structs which indicates who will have access to the created Inbox\n     * @param {UserWithPubKey[]} managers vector of UserWithPubKey structs which indicates who will have access (and have manage rights) to\n     * the created Inbox\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @param {FilesConfig} filesConfig struct to override default files configuration\n     * @param {number} version current version of the updated Inbox\n     * @param {boolean} force force update (without checking version)\n     * @param {boolean} forceGenerateNewKey force to regenerate a key for the Inbox\n     */\n    async updateInbox(inboxId, users, managers, publicMeta, privateMeta, filesConfig, version, force, forceGenerateNewKey) {\n        return this.native.updateInbox(this.servicePtr, [inboxId, users, managers, publicMeta, privateMeta, filesConfig, version, force, forceGenerateNewKey]);\n    }\n    /**\n     * Gets a single Inbox by given Inbox ID.\n     *\n     * @param {string} inboxId ID of the Inbox to get\n     * @returns {Inbox} struct containing information about the Inbox\n     */\n    async getInbox(inboxId) {\n        return this.native.getInbox(this.servicePtr, [inboxId]);\n    }\n    /**\n     * Gets s list of Inboxes in given Context.\n     *\n     * @param {string} contextId ID of the Context to get Inboxes from\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<Inbox>} struct containing list of Inboxes\n     */\n    async listInboxes(contextId, pagingQuery) {\n        return this.native.listInboxes(this.servicePtr, [contextId, pagingQuery]);\n    }\n    /**\n     * Gets public data of given Inbox.\n     * You do not have to be logged in to call this function.\n     *\n     * @param {string} inboxId ID of the Inbox to get\n     * @returns {InboxPublicView} struct containing public accessible information about the Inbox\n     */\n    async getInboxPublicView(inboxId) {\n        return this.native.getInboxPublicView(this.servicePtr, [inboxId]);\n    }\n    /**\n     * Deletes an Inbox by given Inbox ID.\n     * The function also removes the related Thread and Store.\n     *\n     * @param {string} inboxId ID of the Inbox to delete\n     */\n    async deleteInbox(inboxId) {\n        return this.native.deleteInbox(this.servicePtr, [inboxId]);\n    }\n    /**\n     * Prepares a request to send data to an Inbox.\n     * You do not have to be logged in to call this function.\n     *\n     * @param {string} inboxId ID of the Inbox to which the request applies\n     * @param {Uint8Array} data entry data to send\n     * @param {number[]} [inboxFileHandles] optional list of file handles that will be sent with the request\n     * @param {string} [userPrivKey] optional sender's private key which can be used later to encrypt data for that sender\n     * @returns {number} Inbox handle\n     */\n    async prepareEntry(inboxId, data, inboxFileHandles, userPrivKey) {\n        return this.native.prepareEntry(this.servicePtr, [inboxId, data, inboxFileHandles, userPrivKey]);\n    }\n    /**\n     * Sends data to an Inbox.\n     * You do not have to be logged in to call this function.\n     *\n     * @param {string} inboxHandle ID of the Inbox to which the request applies\n     */\n    async sendEntry(inboxHandle) {\n        return this.native.sendEntry(this.servicePtr, [inboxHandle]);\n    }\n    /**\n     * Gets an entry from an Inbox.\n     *\n     * @param {string} inboxEntryId ID of an entry to read from the Inbox\n     * @returns {InboxEntry} struct containing data of the selected entry stored in the Inbox\n     */\n    async readEntry(inboxEntryId) {\n        return this.native.readEntry(this.servicePtr, [inboxEntryId]);\n    }\n    /**\n     * Gets list of entries of given Inbox.\n     *\n     * @param {string} inboxId ID of the Inbox\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<InboxEntry>} struct containing list of entries\n     */\n    async listEntries(inboxId, pagingQuery) {\n        return this.native.listEntries(this.servicePtr, [inboxId, pagingQuery]);\n    }\n    /**\n     * Delete an entry from an Inbox.\n     *\n     * @param {string} inboxEntryId ID of an entry to delete from the Inbox\n     */\n    async deleteEntry(inboxEntryId) {\n        return this.native.deleteEntry(this.servicePtr, [inboxEntryId]);\n    }\n    /**\n     * Creates a file handle to send a file to an Inbox.\n     * You do not have to be logged in to call this function.\n     *\n     * @param {Uint8Array} publicMeta public file meta_data\n     * @param {Uint8Array} privateMeta private file meta_data\n     * @param {number} fileSize size of the file to send\n     * @returns {number} file handle\n     */\n    async createFileHandle(publicMeta, privateMeta, fileSize) {\n        return this.native.createFileHandle(this.servicePtr, [publicMeta, privateMeta, fileSize]);\n    }\n    /**\n     * Sends a file's data chunk to an Inbox.\n     * :::note To send the entire file - divide it into pieces of the desired size and call the function for each fragment. :::\n     * You do not have to be logged in to call this function.\n     *\n     * @param {number} inboxHandle ID of the Inbox to which the request applies\n     * @param {number} inboxFileHandle handle to the file where the uploaded chunk belongs\n     * @param {Uint8Array} dataChunk - file chunk to send\n     */\n    async writeToFile(inboxHandle, inboxFileHandle, dataChunk) {\n        return this.native.writeToFile(this.servicePtr, [inboxHandle, inboxFileHandle, dataChunk]);\n    }\n    /**\n     * Opens a file to read.\n     *\n     * @param {string} fileId ID of the file to read\n     * @returns {number} handle to read file data\n     */\n    async openFile(fileId) {\n        return this.native.openFile(this.servicePtr, [fileId]);\n    }\n    /**\n     * Reads file data.\n     *\n     * @param {number} fileHandle handle to the file\n     * @param {number} length size of data to read\n     * @returns {Uint8Array} buffer with file data chunk\n     */\n    async readFromFile(fileHandle, length) {\n        return this.native.readFromFile(this.servicePtr, [fileHandle, length]);\n    }\n    /**\n     * Moves file's read cursor.\n     *\n     * @param {number} fileHandle handle to the file\n     * @param {number} position sets new cursor position\n     */\n    async seekInFile(fileHandle, position) {\n        return this.native.seekInFile(this.servicePtr, [fileHandle, position]);\n    }\n    /**\n     * Closes the file by given handle.\n     *\n     * @param {number} fileHandle handle to the file\n     * @returns {string} ID of closed file\n     */\n    async closeFile(fileHandle) {\n        return this.native.closeFile(this.servicePtr, [fileHandle]);\n    }\n    /**\n     * Subscribes for the Inbox module main events.\n     */\n    async subscribeForInboxEvents() {\n        return this.native.subscribeForInboxEvents(this.servicePtr, []);\n    }\n    /**\n     * Unsubscribes from the Inbox module main events.\n     */\n    async unsubscribeFromInboxEvents() {\n        return this.native.unsubscribeFromInboxEvents(this.servicePtr, []);\n    }\n    /**\n     * Subscribes for the events in given Inbox\n     * @param {string} inboxId ID of the inbox to subscribe to\n     */\n    async subscribeForEntryEvents(inboxId) {\n        return this.native.subscribeForEntryEvents(this.servicePtr, [inboxId]);\n    }\n    /**\n     * Unsubscribes from the events in given Inbox\n     * @param {string} inboxId ID of the inbox to unsubscribe from\n     */\n    async unsubscribeFromEntryEvents(inboxId) {\n        return this.native.unsubscribeFromEntryEvents(this.servicePtr, [inboxId]);\n    }\n}\nexports.InboxApi = InboxApi;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/InboxApi.ts?");

/***/ }),

/***/ "./src/service/StoreApi.ts":
/*!*********************************!*\
  !*** ./src/service/StoreApi.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.StoreApi = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass StoreApi extends BaseApi_1.BaseApi {\n    native;\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    /**\n     * Creates a new Store in given Context.\n     *\n     * @param {string} contextId ID of the Context to create the Store in\n     * @param {UserWithPubKey[]} users array of UserWithPubKey structs which indicates who will have access to the created Store\n     * @param {UserWithPubKey[]} managers array of UserWithPubKey structs which indicates who will have access (and management rights) to the\n     * created Store\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @returns {string} string created Store ID\n     */\n    async createStore(contextId, users, managers, publicMeta, privateMeta) {\n        return this.native.createStore(this.servicePtr, [contextId, users, managers, publicMeta, privateMeta]);\n    }\n    /**\n     * Updates an existing Store.\n     *\n     * @param {string} storeId ID of the Store to update\n     * @param {UserWithPubKey[]} users array of UserWithPubKey structs which indicates who will have access to the created Store\n     * @param {UserWithPubKey[]} managers array of UserWithPubKey structs which indicates who will have access (and management rights) to the\n     * created Store\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @param {number} version current version of the updated Store\n     * @param {boolean} force force update (without checking version)\n     * @param {boolean} forceGenerateNewKey force to regenerate a key for the Store\n    */\n    async updateStore(storeId, users, managers, publicMeta, privateMeta, version, force, forceGenerateNewKey) {\n        return this.native.updateStore(this.servicePtr, [storeId, users, managers, publicMeta, privateMeta, version, force, forceGenerateNewKey]);\n    }\n    /**\n     * Deletes a Store by given Store ID.\n     *\n     * @param {string} storeId ID of the Store to delete\n     */\n    async deleteStore(storeId) {\n        return this.native.deleteStore(this.servicePtr, [storeId]);\n    }\n    /**\n     * Gets a single Store by given Store ID.\n     *\n     * @param {string} storeId ID of the Store to get\n     * @returns {Store} struct containing information about the Store\n    */\n    async getStore(storeId) {\n        return this.native.getStore(this.servicePtr, [storeId]);\n    }\n    /**\n     * Gets a list of Stores in given Context.\n     *\n     * @param {string} contextId ID of the Context to get the Stores from\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<Store>} struct containing list of Stores\n    */\n    async listStores(contextId, pagingQuery) {\n        return this.native.listStores(this.servicePtr, [contextId, pagingQuery]);\n    }\n    /**\n     * Creates a new file in a Store.\n     *\n     * @param {string} storeId ID of the Store to create the file in\n     * @param {Uint8Array} publicMeta public file meta_data\n     * @param {Uint8Array} privateMeta private file meta_data\n     * @param {number} size size of the file\n     * @returns {number} handle to write data\n     */\n    async createFile(storeId, publicMeta, privateMeta, size) {\n        return this.native.createFile(this.servicePtr, [storeId, publicMeta, privateMeta, size]);\n    }\n    /**\n     * Update an existing file in a Store.\n     *\n     * @param {string} fileId ID of the file to update\n     * @param {Uint8Array} publicMeta public file meta_data\n     * @param {Uint8Array} privateMeta private file meta_data\n     * @param {number} size size of the file\n     * @returns {number} handle to write file data\n     */\n    async updateFile(fileId, publicMeta, privateMeta, size) {\n        return this.native.updateFile(this.servicePtr, [fileId, publicMeta, privateMeta, size]);\n    }\n    /**\n     * Update meta data of an existing file in a Store.\n     *\n     * @param {string} fileId ID of the file to update\n     * @param {Uint8Array} publicMeta public file meta_data\n     * @param {Uint8Array} privateMeta private file meta_data\n     */\n    async updateFileMeta(fileId, publicMeta, privateMeta) {\n        return this.native.updateFileMeta(this.servicePtr, [fileId, publicMeta, privateMeta]);\n    }\n    /**\n     * Writes a file data.\n     *\n     * @param {number} fileHandle handle to write file data\n     * @param {Uint8Array} dataChunk file data chunk\n     */\n    async writeToFile(fileHandle, dataChunk) {\n        return this.native.writeToFile(this.servicePtr, [fileHandle, dataChunk]);\n    }\n    /**\n     * Deletes a file by given ID.\n     *\n     * @param {string} fileId ID of the file to delete\n     */\n    async deleteFile(fileId) {\n        return this.native.deleteFile(this.servicePtr, [fileId]);\n    }\n    /**\n     * Gets a single file by the given file ID.\n     *\n     * @param {string} fileId ID of the file to get\n     * @returns {File} struct containing information about the file\n     */\n    async getFile(fileId) {\n        return this.native.getFile(this.servicePtr, [fileId]);\n    }\n    /**\n     * Gets a list of files in given Store.\n     *\n     * @param {string} storeId ID of the Store to get files from\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<File>} struct containing list of files\n     */\n    async listFiles(storeId, pagingQuery) {\n        return this.native.listFiles(this.servicePtr, [storeId, pagingQuery]);\n    }\n    /**\n     * Opens a file to read.\n     *\n     * @param {string} fileId ID of the file to read\n     * @returns {number} handle to read file data\n     */\n    async openFile(fileId) {\n        return this.native.openFile(this.servicePtr, [fileId]);\n    }\n    /**\n     * Reads file data.\n     *\n     * @param {string} fileHandle handle to write file data\n     * @param {number} length size of data to read\n     * @returns {Uint8Array} array buffer with file data chunk\n     */\n    async readFromFile(fileHandle, length) {\n        return this.native.readFromFile(this.servicePtr, [fileHandle, length]);\n    }\n    /**\n     * Moves read cursor.\n     *\n     * @param {string} fileHandle handle to write file data\n     * @param {number} position new cursor position\n     */\n    async seekInFile(fileHandle, position) {\n        return this.native.seekInFile(this.servicePtr, [fileHandle, position]);\n    }\n    /**\n     * Closes the file handle.\n     *\n     * @param {string} fileHandle handle to read/write file data\n     * @returns {string} ID of closed file\n     */\n    async closeFile(fileHandle) {\n        return this.native.closeFile(this.servicePtr, [fileHandle]);\n    }\n    /**\n     * Subscribes for the Store module main events.\n     */\n    async subscribeForStoreEvents() {\n        return this.native.subscribeForStoreEvents(this.servicePtr, []);\n    }\n    /**\n     * Unsubscribes from the Store module main events.\n     */\n    async unsubscribeFromStoreEvents() {\n        return this.native.unsubscribeFromStoreEvents(this.servicePtr, []);\n    }\n    /**\n     * Subscribes for the events in given Store\n     * @param {string} storeId ID of the store to subscribe to\n     */\n    async subscribeForFileEvents(storeId) {\n        return this.native.subscribeForFileEvents(this.servicePtr, [storeId]);\n    }\n    /**\n     * Unsubscribes from the events in given Store\n     * @param {string} storeId ID of the store to unsubscribe from\n     */\n    async unsubscribeFromFileEvents(storeId) {\n        return this.native.unsubscribeFromFileEvents(this.servicePtr, [storeId]);\n    }\n}\nexports.StoreApi = StoreApi;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/StoreApi.ts?");

/***/ }),

/***/ "./src/service/ThreadApi.ts":
/*!**********************************!*\
  !*** ./src/service/ThreadApi.ts ***!
  \**********************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ThreadApi = void 0;\nconst BaseApi_1 = __webpack_require__(/*! ./BaseApi */ \"./src/service/BaseApi.ts\");\nclass ThreadApi extends BaseApi_1.BaseApi {\n    native;\n    constructor(native, ptr) {\n        super(ptr);\n        this.native = native;\n    }\n    /**\n     * Creates new Thread in given Context.\n     *\n     * @param {string} contextId ID of the Context to create the Thread in\n     * @param {UserWithPubKey[]} users array of UserWithPubKey structs which indicates who will have access to the created Thread\n     * @param {UserWithPubKey[]} managers array of UserWithPubKey structs which indicates who will have access (and management rights) to\n     * the created Thread\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @returns {string} created Thread ID\n     */\n    async createThread(contextId, users, managers, publicMeta, privateMeta) {\n        return this.native.createThread(this.servicePtr, [contextId, users, managers, publicMeta, privateMeta]);\n    }\n    /**\n     * Updates existing Thread.\n     *\n     * @param {string} threadId ID of the Thread to update\n     * @param {UserWithPubKey[]} users array of UserWithPubKey structs which indicates who will have access to the created Thread\n     * @param {UserWithPubKey[]} managers array of UserWithPubKey structs which indicates who will have access (and management rights) to\n     * the created Thread\n     * @param {Uint8Array} publicMeta public (unencrypted) meta data\n     * @param {Uint8Array} privateMeta private (encrypted) meta data\n     * @param {number} version current version of the updated Thread\n     * @param {boolean} force force update (without checking version)\n     * @param {boolean} forceGenerateNewKey force to regenerate a key for the Thread\n     */\n    async updateThread(threadId, users, managers, publicMeta, privateMeta, version, force, forceGenerateNewKey) {\n        return this.native.updateThread(this.servicePtr, [threadId, users, managers, publicMeta, privateMeta, version, force, forceGenerateNewKey]);\n    }\n    /**\n     * Deletes a Thread by given Thread ID.\n     *\n     * @param {string} threadId ID of the Thread to delete\n     */\n    async deleteThread(threadId) {\n        return this.native.deleteThread(this.servicePtr, [threadId]);\n    }\n    /**\n     * Gets a Thread by given Thread ID.\n     *\n     * @param {string} threadId ID of Thread to get\n     * @returns {Thread} struct containing info about the Thread\n     */\n    async getThread(threadId) {\n        return this.native.getThread(this.servicePtr, [threadId]);\n    }\n    /**\n     * Gets a list of Threads in given Context.\n     *\n     * @param {string} contextId ID of the Context to get the Threads from\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<Thread>} struct containing a list of Threads\n     */\n    async listThreads(contextId, pagingQuery) {\n        return this.native.listThreads(this.servicePtr, [contextId, pagingQuery]);\n    }\n    /**\n     * Gets a message by given message ID.\n     *\n     * @param {string} messageId ID of the message to get\n     * @returns {Message} struct containing the message\n     */\n    async getMessage(messageId) {\n        return this.native.getMessage(this.servicePtr, [messageId]);\n    }\n    /**\n     * Gets a list of messages from a Thread.\n     *\n     * @param {string} threadId ID of the Thread to list messages from\n     * @param {PagingQuery} pagingQuery struct with list query parameters\n     * @returns {PagingList<Message>} struct containing a list of messages\n     */\n    async listMessages(threadId, pagingQuery) {\n        return this.native.listMessages(this.servicePtr, [threadId, pagingQuery]);\n    }\n    /**\n     * Sends message in a Thread.\n     *\n     * @param {string} threadId ID of the Thread to send message to\n     * @param {Uint8Array} publicMeta public message meta_data\n     * @param {Uint8Array} privateMeta private message meta_data\n     * @param {Uint8Array} data content of the message\n     * @returns {string} ID of the new message\n     */\n    async sendMessage(threadId, publicMeta, privateMeta, data) {\n        return this.native.sendMessage(this.servicePtr, [threadId, publicMeta, privateMeta, data]);\n    }\n    /**\n     * Deletes a message by given message ID.\n     *\n     * @param {string} messageId ID of the message to delete\n     */\n    async deleteMessage(messageId) {\n        return this.native.deleteMessage(this.servicePtr, [messageId]);\n    }\n    /**\n     * Update message in a Thread.\n     *\n     * @param {string} messageId ID of the message to update\n     * @param {Uint8Array} publicMeta public message meta_data\n     * @param {Uint8Array} privateMeta private message meta_data\n     * @param {Uint8Array} data content of the message\n     */\n    async updateMessage(messageId, publicMeta, privateMeta, data) {\n        return this.native.updateMessage(this.servicePtr, [messageId, publicMeta, privateMeta, data]);\n    }\n    /**\n     * Subscribes for the Thread module main events.\n     */\n    async subscribeForThreadEvents() {\n        return this.native.subscribeForThreadEvents(this.servicePtr, []);\n    }\n    /**\n     * Unsubscribes from the Thread module main events.\n     */\n    async unsubscribeFromThreadEvents() {\n        return this.native.unsubscribeFromThreadEvents(this.servicePtr, []);\n    }\n    /**\n     * Subscribes for the events in given Thread\n     * @param {string} threadId ID of the thread to subscribe to\n     */\n    async subscribeForMessageEvents(threadId) {\n        return this.native.subscribeForMessageEvents(this.servicePtr, [threadId]);\n    }\n    /**\n     * Unsubscribes from the events in given Thread\n     * @param {string} threadId ID of the thread to unsubscribe from\n     */\n    async unsubscribeFromMessageEvents(threadId) {\n        return this.native.unsubscribeFromMessageEvents(this.servicePtr, [threadId]);\n    }\n}\nexports.ThreadApi = ThreadApi;\n\n\n//# sourceURL=webpack://privmx-endpoint-wasm-api/./src/service/ThreadApi.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.ts");
/******/ 	
/******/ })()
;